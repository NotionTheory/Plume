<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
  <meta name="HandheldFriendly" content="true" />
</head>
<body>
  <div id="fsc">
    <canvas id="frontBuffer" tabindex="1"></canvas>
    <progress></progress>
    <button id="exitFullscreen" type="button" title="Exit fullscreen" style="display:none">&leftarrow;</button>
  </div>
  <div id="fsb">
    <button id="btn1" type="button">Empty button</button>
    <button id="btn2" type="button">Log button</button>
  </div>
  <div id="errorLog"></div>
  <script src="bare-bones-logger.min.js"></script>
  <script>logger.setup(logger.DOM, "#errorLog");</script>
  <script src="Primrose.min.js"></script>
  <script>
  WebVRStandardMonitor();

  var fsb = document.getElementById("fsb");
  navigator.getVRDisplays().then(function(displays){
    displays.forEach(function(display){
      var button = document.createElement("button");
      button.type = button;
      button.onclick = function(){
        display.requestPresent([{source: renderer.domElement}])
      };
      button.appendChild(document.createTextNode(display.displayName));
      fsb.appendChild(button);
    });
  });

document.getElementById("btn2").onclick = function(){
  console.log(performance.now());
};

function get(file, type, done) {
  if(done === undefined){
    done = type;
    type = "";
  }
  var x = new XMLHttpRequest();
  x.onload = function () {
    return done(x.response);
  };
  x.responseType = type;
  x.onprogress = prog.thunk;
  x.open("GET", file);
  x.send();
}

var prog = {
  bar: null,
  files: {},
  loaded: 0,
  total: 0,

  thunk: function thunk(evt) {
    var file = evt.target.responseURL || evt.target.currentSrc;
    if (file) {
      if (!prog.files[file]) {
        prog.files[file] = {};
      }
      var f = prog.files[file];
      if (typeof evt.loaded === "number") {
        f.loaded = evt.loaded;
        f.total = evt.total;
      } else {
        var bs = evt.srcElement.buffered;
        var min = Number.MAX_VALUE,
            max = Number.MIN_VALUE;
        for (var i = 0; i < bs.length; ++i) {
          min = Math.min(min, bs.start(i));
          max = Math.max(max, bs.end(i));
        }
        f.loaded = 1000 * max;
        f.total = 1000 * evt.srcElement.duration;
      }
    }

    var total = 0,
        loaded = 0;
    for (var key in prog.files) {
      var _f = prog.files[key];
      loaded += _f.loaded;
      total += _f.total;
    }

    prog.loaded = loaded;
    prog.total = total;

    if (!prog.bar) {
      prog.bar = document.querySelector("progress");
    }

    if (prog.bar) {
      if(prog.TOTAL || total) {
        prog.bar.max = prog.TOTAL || total;
      }
      prog.bar.value = loaded;
    }
  }
};

var isiOS = /iP(hone|od|ad)/.test(navigator.userAgent || "");

var renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById("frontBuffer"),
  antialias: true,
  alpha: true,
  logarithmicDepthBuffer: false
}), scene = new THREE.Scene(),
  camera = new THREE.PerspectiveCamera(75, 1, 0.01, 100),
  videoTexture,
  lastTime;

renderer.sortObjects = true;
renderer.setClearColor(0x007f00);

get("house1.html", "document", function(doc){
  var video = doc.querySelector("video");
  video.onprogress = prog.thunk;
  video.onloadmetadata = prog.thunk;
  video.oncanplay = function(){
    video.style.display = "none";
    videoTexture = new THREE.Texture(video);
    var geometry = new THREE.PlaneBufferGeometry(1, 1),
      material = new THREE.MeshBasicMaterial({
        map: videoTexture
      }),
      mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    mesh.position.set(0, 0, -1);
  };
  if(isiOS && video.loop){
    video.onend = function(){
      video.play();
    };
  }
  document.body.appendChild(video);
  video.play();
});

function paint(dt){
  requestAnimationFrame(paint);
  renderer.render(scene, camera);
  if(videoTexture && videoTexture.image.currentTime !== lastTime){
    lastTime = videoTexture.image.currentTime;
    videoTexture.needsUpdate = true;
  }
}
requestAnimationFrame(paint);
  </script>
</body>
</html>